= Playbooks good practices

== Keep your playbooks as simple as possible
[%collapsible]
====
Explanations:: Don't put too much logic in your playbook, put it in your roles, and try to limit your playbooks to a list of a roles.

Rationale:: Roles are meant to be re-used and the structure helps you to make your code re-usable.
The more code you put in roles, the higher the chances you, or others, can reuse it.
Also, if you follow the <<structures/README.adoc#_define_which_structure_to_use_for_which_purpose,type-function pattern>>, you can very easily create new (type) playbooks by just re-shuffling the roles.
You can really have one playbook for each purpose without having to duplicate a lot of code.

Examples:: 
+
.An example of playbook containing only roles
[source,yaml]
----
- name: a playbook can solely be a list of roles
  hosts: all
  gather_facts: false
  become: false

  roles:

    - role1
    - role2 
    - role3
----
+
TIP: we'll explain later why there might be a case for using include_role/import_role tasks instead of the role section.
====

== Use tags cautiously either for roles or for complete purposes
[%collapsible]
====
Explanations:: either use tags called like the roles to switch on/off single roles, or to reach a complete meaningful suite of tasks, don't set tags which can't be used on their own.
Don't force your users to learn the right sequence of tags necessary to get a meaningful result, one tag should be enough.

Rationale:: there is nothing worse than tags which can't be used, they bare the risk to destroy something by being called standalone.
An acceptable exception is the pattern to use the role name as tag name, which can be useful while developing the playbook to test, or exclude, individual roles.

Examples:: 
+
.An example of playbook importing roles with tags
[source,yaml]
----
- name: a playbook can be a list of roles imported with tags
  hosts: all
  gather_facts: false
  become: false

  tasks:

    - name: import role1
      import_role:
        name: role1
      tags:
        - role1
        - deploy
    - name: import role2
      import_role:
        name: role2
      tags:
        - role2
        - deploy
        - configure
    - name: import role3
      import_role:
        name: role3
      tags:
        - role3
        - configure
----
+
You see that each role can be skipped/run individually, but also that the tags `deploy` and `configure` can be used to do something we'll assume to be meaningful, without having to explain at length what they do.
+
The same approach is also possible with `include_role` but requires additionally to `apply` the same tags to the role's tasks, which doesn't make the code easier to read:
+
.An example of playbook including roles with tags
[source,yaml]
----
- name: a playbook can be a list of roles included with tags applied
  hosts: all
  gather_facts: false
  become: false

  tasks:

    - name: include role1
      include_role:
        name: role1
        apply:
          tags: [role1, deploy]
      tags:
        - role1
        - deploy
    - name: include role2
      include_role:
        name: role2
        apply:
          tags: [role2, deploy, configure]
      tags:
        - role2
        - deploy
        - configure
    - name: include role3
      include_role:
        name: role3
        apply:
          tags: [role3, configure]
      tags:
        - role3
        - configure
----
+
TIP: the two list formats for tags are completely equivalent to each other in YAML.

====

